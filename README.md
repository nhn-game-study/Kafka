# Kafka 단계별 학습 목표

## 전체 흐름 요약

```
WebFlux 비동기 처리 → Spring 이벤트 처리 → Kafka 이벤트 처리
(단일 서버 내부 이벤트)               (서버 외부 이벤트 브로커)
```

## 1단계: Spring WebFlux 기반 비동기 알림 전송 서비스

### 목표
* Mono, Flux, Scheduler 개념을 체득한다.
* WebFlux 기반으로 비동기 알림 전송 API를 만든다.

### 장점
* 비즈니스 서버가 알림 서버와 비동기 통신할 수 있다.
* 알림 서버 지연이나 실패가 있어도 비즈니스 서버의 응답 흐름은 막히지 않는다.

### 한계
* 알림 발송 로직이 여전히 Controller, Service와 직접 연결되어 있다.
* 발송 실패에 대한 에러 핸들링(fallback, retry 등)을 직접 관리해야 한다.

<br>

## 2단계: 이벤트 기반으로 리팩터링

### 기존 방식의 문제점
* Controller가 알림 발송 요청을 직접 호출한다.
* 저장 로직과 발송 로직이 강하게 결합되어 있다.

### 이벤트 기반으로 바꿨을 때 장점
* 관심사의 분리 
  * Controller는 “요청 받고 저장”까지만 담당하고, “발송 요청”은 이벤트로 위임한다.
* 비동기 최적화 
  * 이벤트 발행은 완전히 비동기로 처리되어 API 응답 속도가 빨라진다.
* 확장성 향상 
  * 이메일, SMS, 푸시 알림 등 추가해도 Controller 수정 없이 리스너만 추가하면 된다.
* 에러 격리 
  * 발송 실패가 발생해도 Controller에는 영향이 없다. 실패는 리스너에서 로깅, Retry로 따로 처리한다.
* 테스트 용이성
  * Controller 테스트 시 발송 로직이 없어 단위 테스트가 간단해진다.
* 유지보수성 강화 
  * 발송 로직을 수정하거나 교체할 때 Controller를 수정할 필요가 없다.

### 목표
* ApplicationEventPublisher를 사용하여 발송 요청을 이벤트로 분리한다.
* 알림 전송 요청 시 바로 200 OK 응답을 반환한다.
* 알림 발송은 이벤트 리스너에서 비동기로 수행한다.

### 장점
* 비동기 처리 최적화 + 로직 분리 → 깔끔한 구조로 서비스 품질 향상

### 단점
* 서버 분산 환경에서는 한계가 있음
* ApplicationEventPublisher 기반 이벤트는 스프링 애플리케이션 내부에서만 작동
* 분산 환경에서는 한 서버에서 이벤트 발생했지만, 다른 서버에서 리스너를 실행할 수 없음
* 이를 해결하려면? 
  * Kafka, RabbitMQ 등 외부 메시지 브로커를 사용해 이벤트를 분산 처리 가능하도록 개선 필요 (→ 3단계)

### 이후 발전 방향: Kafka 기반 구조로 확장
* ApplicationEventPublisher → KafkaTemplate.send(...) 구조로 교체
* 발행자 / 구독자가 완전히 분리됨
* 분산 환경에서도 이벤트 처리 가능
